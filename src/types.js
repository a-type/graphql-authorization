//@flow

export type User = {
  id: string,
  role: string,
};

export type AuthContext = {
  user: User,
  prisma: Prisma,
  graphqlContext: {},
};

export type Prisma = {
  query: {},
  mutation: {},
  exists: () => mixed,
  request: () => mixed,
};

export type QueryRootData = {
  rootFieldName: string,
  rootTypeName: string,
  inputs: { [string]: mixed },
};

export type QueryInputs = {
  [string]: mixed,
};

export type AuthResolverValue = boolean | string;
export type AuthResolverResult = Promise<AuthResolverValue>;
export type AuthResolverFunctionParams = {
  fieldValue: mixed,
  fieldName: ?string,
  fieldPath: string,
  typeValue: {},
  typeName: string,
  context: AuthContext,
} & QueryRootData;
export type AuthResolverFunction = (
  params: AuthResolverFunctionParams,
) => AuthResolverResult;
export type AuthResolver =
  | boolean
  | string
  | AuthResolverFunction
  | { [string]: AuthResolver };

export type AuthResult = { [string]: AuthResult } | Array<AuthResult> | boolean;

export type AuthResource = {
  read: { [string]: AuthResolver },
  write: { [string]: AuthResolver },
};

export type AuthPermissions = {
  [string]: AuthResource,
};
export type RoleAuthMapping = {
  inherits: string,
  permissions: AuthPermissions,
};

export type AuthMapping = {
  [string]: RoleAuthMapping,
};

export type QueryResponse = Promise<{}>;
export type QueryFunction = (inputs: {}, info: string) => QueryResponse;

export type WithAuthorizationOptions = {
  autoGenerateDerivedTypePermissions: boolean,
};
export type AuthType = 'read' | 'write';
export type WrappedQueryFunction = (
  inputs: {},
  info: string,
  ctx: {},
) => QueryResponse;
